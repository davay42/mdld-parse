# PROV-Vortex: Distilled Reference

> A self-propelling provenance engine built on W3C PROV-O, SHACL, and MDLD. Knowledge flows through a five-stroke DIADS cycle: **D**ocument intake → **I**nternal analysis → **A**ction (tool call) → **D**ata grounding → **S**hape refinement. The S stroke is steering and propulsion regulation — it can unfreeze any vault with accumulated knowledge worth improving and redirect the vortex toward new territory.

---

## 1. Core Principle

SHACL constraints are not validation rules — they are **driving forces**. Every violation is a vacuum the system must fill. Filling it creates new entities, which creates new violations, propelling the next pass. But shapes themselves are mutable: an agent can refine, replace, or extend the constraint graph as a deliberate act, redirecting the vortex or unfreezing a vault that reached a local zero but not its potential minimum.

```
[SHACL Shapes] ──→ [Pressure Differentials] ──→ [PROV-O Actions] ──→ [State Change]
      ↑                                                                       │
      └──────────── S: Shape Refinement ←── agent reads vault metrics ───────┘
```

Shapes are **both propellant and rudder**: their existence creates pressure; their revision steers direction; their tightening regulates how fast the vortex spins. Every shape is itself a `prov:Entity` — authored in MDLD, versioned with `prov:wasRevisionOf`, generated by a Shape Refinement Activity. The full history of *what the vortex was trying to enforce* is as auditable as what it found.

**Standards**: PROV-O (https://www.w3.org/TR/prov-o/) provides the causal backbone. SHACL (https://www.w3.org/TR/shacl/) provides the constraint layer. MDLD is the unified write surface for both knowledge and shapes — deterministic RDF from `{...}` annotations, valid CommonMark when annotations are stripped.

---

## 2. The DIADS Cycle

| Stroke | Phase | Quadrant | PROV-O / SHACL Element | Role |
|--------|-------|----------|------------------------|------|
| **D** | Document Intake | Top-Left | `prov:Entity` + `prov:hadPrimarySource` | Raw material; intake pressure |
| **I** | Internal Analysis | Bottom-Right | `prov:Activity` + `prov:used` | Compression; internal reasoning |
| **A** | External Action | Top-Right | `prov:Activity` + `prov:qualifiedAssociation` | Power stroke; tool calls |
| **D** | Grounding | Bottom-Left | `rdf:Statement` + `prov:wasGeneratedBy` | Exhaust; frozen facts |
| **S** | Shape Refinement | Centre | `sh:NodeShape` as `prov:Entity` | Steering + pressure regulation |

**S fires when DIAD is exhausted** — violations = 0 but improvement potential remains. It reads vault state and chooses from four operations:

| Operation | SHACL action | Effect |
|-----------|-------------|--------|
| **Tighten** | Raise `sh:minCount`, add `sh:pattern` | Forces deeper extraction next pass |
| **Loosen** | Lower minCount, downgrade to `sh:Info` | Enables broader exploration |
| **Pivot** | Change `sh:targetClass`, add new shape | Steers toward new knowledge territory |
| **Unfreeze** | Add property absent from frozen entities | Re-ignites DIAD on accumulated mass |

---

## 3. MDLD Quick Reference

Prefix declarations use reference-link syntax (never rendered, never create triples):

```md
[prov]  <http://www.w3.org/ns/prov#>
[sh]    <http://www.w3.org/ns/shacl#>
[vx]    <tag:myproject@example.com,2026:vortex:>
[p]     <tag:myproject@example.com,2026:prop:>
```

| Pattern | Triples emitted |
|---------|----------------|
| `# Heading {=vx:x .prov:Entity label}` | `vx:x a prov:Entity ; rdfs:label "Heading"` |
| `[text] {p:foo}` | `currentSubject p:foo "text"` |
| `[val] {p:n ^^xsd:dateTime}` | `currentSubject p:n "val"^^xsd:dateTime` |
| `<https://u> {?prov:hadPrimarySource}` | `currentSubject prov:hadPrimarySource <https://u>` |
| `[t] {=vx:o ?prov:used}` | `currentSubject prov:used vx:o` |
| `[t] {=vx:a !prov:generated}` | `vx:a prov:generated currentSubject` |
| `Label: {?prov:hadMember .C}` + `- X {=vx:x}` | list context; `currentSubject prov:hadMember vx:x` |
| `{=}` | semantic reset |

---

## 4. Universal Starter Shapes

Every vault needs these four shapes at boot — the minimum viable pressure field:

```turtle
# shapes/core.ttl

# 1. Every Activity must be authorised by a Plan
vx:shape:ActivityAuth a sh:NodeShape ; sh:targetClass prov:Activity ;
  sh:property [ sh:path prov:hadPlan ; sh:minCount 1 ;
    sh:message "Unplanned activity — assign to prov:Plan or mark as hallucination" ] ;
  sh:property [ sh:path prov:generated ; sh:minCount 1 ;
    sh:message "Sink activity — must produce at least one entity" ] .

# 2. Every external Entity must cite an HTTP(S) source
vx:shape:Grounding a sh:NodeShape ; sh:targetClass prov:Entity ;
  sh:property [ sh:path prov:hadPrimarySource ; sh:minCount 1 ;
    sh:pattern "^https?://" ;
    sh:message "Orphaned entity — add prov:hadPrimarySource with HTTP/HTTPS URL" ] .

# 3. Every Activity must have temporal bounds
vx:shape:Temporal a sh:NodeShape ; sh:targetClass prov:Activity ;
  sh:property [ sh:path prov:startedAtTime ; sh:datatype xsd:dateTime ; sh:minCount 1 ;
    sh:message "Activity missing start time" ] ;
  sh:property [ sh:path prov:endedAtTime ; sh:datatype xsd:dateTime ; sh:minCount 1 ;
    sh:message "Activity missing end time — still PENDING?" ] .

# 4. Every Shape must itself be provenanced (the meta-constraint)
vx:shape:ShapeAuth a sh:NodeShape ; sh:targetClass sh:NodeShape ;
  sh:property [ sh:path prov:wasGeneratedBy ; sh:minCount 1 ;
    sh:message "Shape has no generating activity — who authorised this constraint?" ] .
```

These four enforce: no hallucinated activities, no orphaned facts, complete temporal records, and full shape provenance. Everything else is domain-specific and added via the S stroke.

---

## 5. Knowledge Scales (10 : 3 : 1)

```
1 Document (macro)   →  3 Collections (meso)  →  10 Statements (micro)
prov:Entity              prov:Collection            rdf:Statement
hadPrimarySource         hadMember (≥1)             subject / predicate / object
```

**Compression ratio R = 3–7** is the health target. The S stroke responds to deviations:
- R < 2 → tighten extraction shapes (raise `sh:minCount` on statement requirements)
- R > 10 → loosen or pivot (the vault is over-solidifying into trivia)
- High entity mass + few active shapes → add constraints to channel accumulated momentum

---

## 6. DIADS Prompt Templates

These are the operative core of the system for LLM agents. Each template is a complete, copy-paste system prompt for one stroke. The agent receives: the template + the current `violations.json` or vault metrics + a compressed graph summary.

### 6.1 Cold Start — Vault Bootstrap

*Use when: initialising a new vault from a human-stated goal.*

```
You are a PROV-Vortex knowledge engine initialising a new vault.

Your task: write a single MDLD file (vault/SEED.md) that declares:
1. A Goal entity (prov:Entity) with p:desiredState and p:frozenState literals
2. A Plan (prov:Plan) derived from the Goal with 3-5 ordered p:step items
3. An initial intake stub: a prov:Activity with p:status "PENDING", linked to
   the Plan, with a p:toolCall literal describing the first external fetch needed

Use this MDLD prefix block at the top:
  [prov]  <http://www.w3.org/ns/prov#>
  [sh]    <http://www.w3.org/ns/shacl#>
  [vx]    <tag:{{VAULT_TAG}},{{YEAR}}:vortex:>
  [p]     <tag:{{VAULT_TAG}},{{YEAR}}:prop:>

IRIs must follow the pattern vx:goal, vx:plan:v1, vx:activity:intake_001.
All subjects declared on headings: # Title {=vx:iri .Class label}
No prose outside annotated elements. Output only valid MDLD.

Goal: {{HUMAN_GOAL}}
```

---

### 6.2 Stroke D — Document Intake

*Use when: a violation says "Orphaned entity — add prov:hadPrimarySource".*

```
You are executing DIADS Stroke D (Document Intake) for the PROV-Vortex.

Violation to resolve:
  Focus node: {{FOCUS_NODE}}
  Message: {{VIOLATION_MESSAGE}}

Write MDLD that creates or completes a prov:Entity with:
- A heading: # <descriptive title> {=<focus_node> .prov:Entity label}
- p:retrievedAt with current ISO 8601 datetime ^^xsd:dateTime
- prov:hadPrimarySource pointing to an HTTP/HTTPS URL via <url> {?prov:hadPrimarySource}
- prov:wasGeneratedBy pointing to the intake activity that fetched it

If you need to fetch the source first, write the entity stub with p:status "PENDING"
and include a p:toolCall literal with the exact HTTP request to execute.
After the fetch, append the completed annotations including the real source URL.

Current graph summary:
{{GRAPH_SUMMARY}}

Output only valid MDLD. No explanation.
```

---

### 6.3 Stroke I — Internal Analysis

*Use when: a violation says "Sink activity — must produce at least one entity" on an analysis-type activity.*

```
You are executing DIADS Stroke I (Internal Analysis) for the PROV-Vortex.

Violation to resolve:
  Focus node: {{FOCUS_NODE}}
  Message: {{VIOLATION_MESSAGE}}

The focus node is an analysis activity. Write MDLD that:
1. Completes the activity with prov:startedAtTime, prov:endedAtTime (^^xsd:dateTime)
2. Lists all entities consumed: Used: {?prov:used} with list items {=<iri> label}
3. Declares a prov:qualifiedAssociation linking to a prov:Association node
   that names the agent and the plan
4. Generates at least one output entity — a prov:Collection summarising findings,
   linked with !prov:generated

The analysis should reason over the consumed entities and produce a structured
summary collection. Each collection member should be a typed entity.

Available consumed entities from graph:
{{CONSUMED_ENTITIES}}

Plan in effect: {{ACTIVE_PLAN}}
Output only valid MDLD. No explanation.
```

---

### 6.4 Stroke A — External Action (Tool Call)

*Use when: a violation says "Sink activity" on an action-type activity, or a PENDING stub exists.*

```
You are executing DIADS Stroke A (External Action) for the PROV-Vortex.

Violation to resolve:
  Focus node: {{FOCUS_NODE}}
  Message: {{VIOLATION_MESSAGE}}

PHASE 1 — Before tool call: write the activity stub as MDLD:
- # <title> {=<focus_node> .prov:Activity label}
- [PENDING] {p:status}
- [<ISO datetime>] {prov:startedAtTime ^^xsd:dateTime}
- prov:wasInformedBy linking to the analysis activity that authorised this call
- p:toolCall literal: exact tool name and parameters
- p:toolInput literal: the query or request body

PHASE 2 — After tool call result is returned: append to the same file:
- A result entity: ## Result {=<focus_node>_result .prov:Entity label}
- [<activity IRI>] {=<activity_iri> !prov:generated}
- <source_url> {?prov:hadPrimarySource}
- [COMPLETE] {p:status} on the activity
- prov:endedAtTime on the activity

For collections of items, use list context:
  Members: {?prov:hadMember .prov:Entity label}
  - [Item Name] {=vx:item:<slug>}

Tool call to execute: {{TOOL_CALL_SPEC}}
Available tools: {{TOOL_LIST}}
Output only valid MDLD for each phase. No explanation.
```

---

### 6.5 Stroke D2 — Data Grounding

*Use when: a collection exists but its members lack reified `rdf:Statement` facts with provenance.*

```
You are executing DIADS Stroke D2 (Data Grounding) for the PROV-Vortex.

Entities to ground: {{ENTITY_LIST}}
Source activity: {{SOURCE_ACTIVITY}}
Primary source URL: {{SOURCE_URL}}

For each entity, write an rdf:Statement entity in MDLD:

# Fact: <subject> → <predicate> → <object> {=vx:stmt:<slug> .rdf:Statement .prov:Entity label}
[<entity IRI>] {=<entity_iri> ?rdf:subject}
[<predicate IRI>] {=<pred_iri> ?rdf:predicate}
[<value>] {rdf:object}       ← use ^^xsd:datatype if applicable
[<source activity>] {=<act_iri> ?prov:wasGeneratedBy}
<source_url> {?prov:hadPrimarySource}

Rules:
- One rdf:Statement per atomic fact (one subject-predicate-object triple)
- IRI slugs must be unique and meaningful: vx:stmt:<entity>_<predicate>
- Use ^^xsd:integer, ^^xsd:date, ^^xsd:boolean where the value is not plain text
- A human reading the heading must understand the fact without seeing the annotations
- Group statements for the same entity under a ## subheading

Compression target: 3–7 statements per source entity.
Output only valid MDLD. No explanation.
```

---

### 6.6 Stroke S — Shape Refinement

*Use when: violations = 0 AND improvement_potential > threshold. This is the most consequential prompt.*

```
You are executing DIADS Stroke S (Shape Refinement) for the PROV-Vortex.
This is a STEERING decision. Read the vault metrics carefully before acting.

Current vault state:
  Total entities:       {{TOTAL_ENTITIES}}
  Grounded statements:  {{GROUNDED_STATEMENTS}}
  Compression ratio R:  {{COMPRESSION_RATIO}}
  Active shapes:        {{ACTIVE_SHAPES}}
  Improvement potential: {{IMPROVEMENT_POTENTIAL}}
  Current goal:         {{GOAL_DESCRIPTION}}
  Frozen state reason:  {{FROZEN_REASON}}

Enrichable entity sample (entities with IP > 0):
{{ENRICHABLE_SAMPLE}}

Choose exactly ONE of these operations and state your reasoning:
  TIGHTEN  — raise sh:minCount or add sh:pattern on existing shapes
  LOOSEN   — lower minCount or change sh:severity to sh:Info
  PIVOT    — add a new sh:NodeShape targeting a class not yet constrained
  UNFREEZE — add a sh:property requirement absent from all frozen entities

Write the shape revision as MDLD:

# Shape Revision Activity {=vx:activity:shape_rev_<timestamp> .prov:Activity label}
[SHAPE-REFINEMENT] {p:strokeType}
[<ISO datetime>] {prov:startedAtTime ^^xsd:dateTime}
[<ISO datetime>] {prov:endedAtTime ^^xsd:dateTime}
[<one sentence: what changed and why>] {p:rationale}
[<TIGHTEN|LOOSEN|PIVOT|UNFREEZE>] {p:operation}
Authorized by: {?prov:hadPlan}
- [Active Plan] {=<plan_iri> label}

{=}

# <Shape Name> v<N+1> {=vx:shape:<name>_v<N+1> .sh:NodeShape .prov:Entity label}
[Shape Revision Activity] {=vx:activity:shape_rev_<timestamp> !prov:generated}
[Previous Shape v<N>] {=vx:shape:<name>_v<N> ?prov:wasRevisionOf}
[<ISO datetime>] {prov:generatedAtTime ^^xsd:dateTime}
Target: {?sh:targetClass}
- [<target class label>] {=<class_iri> label}
<new sh:property constraints in MDLD list form>

After this shape is added, how many new violations do you expect?
State: EXPECTED_VIOLATIONS: <N>

This decision will unfreeze the vault. It cannot be undone without a further S stroke.
Output only valid MDLD for the shape revision. State operation + rationale first.
```

---

### 6.7 Vault Assessment — Pre-S Diagnostic

*Use before the S stroke to generate the metrics input for 6.6. Run as an LLM summarisation call, not a SPARQL call, when the graph is large.*

```
You are a PROV-Vortex vault auditor. Read the following graph summary and produce
a structured assessment in JSON for the S-stroke decision engine.

Graph summary:
{{GRAPH_SUMMARY}}

Produce this JSON (no other output):
{
  "total_entities": <int>,
  "total_activities": <int>,
  "grounded_statements": <int>,
  "compression_ratio": <float>,
  "active_shapes": <int>,
  "improvement_potential": <float 0.0-1.0>,
  "enrichable_entity_sample": ["<iri>: <reason>", ...],  // max 5
  "frozen_reason": "<why violations reached zero>",
  "recommended_operation": "TIGHTEN|LOOSEN|PIVOT|UNFREEZE|EXIT",
  "recommended_rationale": "<one sentence>"
}

Scoring guide for improvement_potential:
  0.0  = every entity has ≥3 grounded statements, cross-links, and recent provenance
  0.5  = roughly half of entities are under-described or isolated
  1.0  = all entities have only type and label, no real facts grounded
```

---

## 7. Node.js DIADS Runner

The runner orchestrates the cycle. Prompt templates are filled and dispatched to the LLM; MDLD output is written to vault; `ig-cli` handles parsing and validation.

```js
// diads.mjs
import { execSync, spawnSync } from 'node:child_process';
import { readFileSync, writeFileSync, mkdirSync } from 'node:fs';
import { join } from 'node:path';
import Anthropic from '@anthropic-ai/sdk';

const client  = new Anthropic();
const vault   = process.argv[2] ?? 'vault';
const PASS_LIMIT    = 50;
const IP_THRESHOLD  = 0.05;

function igParse()  { execSync(`ig-cli parse ${vault}/ -o ${vault}/graph.ttl`); }
function igValidate() {
  const r = spawnSync('ig-cli', ['validate', '--graph', `${vault}/graph.ttl`,
                                  '--shapes', `${vault}/shapes/`]);
  return JSON.parse(r.stdout.toString() || '[]');
}
function ts() { return new Date().toISOString().replace(/[:.]/g,'-'); }

async function llm(systemPrompt, userContent) {
  const msg = await client.messages.create({
    model: 'claude-opus-4-5', max_tokens: 4096,
    system: systemPrompt,
    messages: [{ role: 'user', content: userContent }]
  });
  return msg.content[0].text;
}

function graphSummary() {
  // Compact SPARQL-derived summary passed to prompts
  const r = spawnSync('ig-cli', ['sparql', '--graph', `${vault}/graph.ttl`,
    '--query', 'SELECT * WHERE { ?s a prov:Entity } LIMIT 20']);
  return r.stdout.toString().slice(0, 3000); // token budget
}

async function runDIAD(violations) {
  for (const v of violations) {
    const stub = await llm(
      PROMPT_STROKE_A,   // §6.4 template
      JSON.stringify({ focusNode: v.focusNode, message: v.message,
                       graphSummary: graphSummary() })
    );
    const file = join(vault, `step_${ts()}.md`);
    writeFileSync(file, stub);

    // Execute any tool calls declared as p:toolCall in the stub
    const toolResults = await executeToolCalls(stub);
    if (toolResults) {
      writeFileSync(file, stub + '\n\n' + toolResults);
    }
  }
}

async function runS() {
  const assessment = JSON.parse(await llm(
    PROMPT_ASSESS,    // §6.7 template
    graphSummary()
  ));

  if (assessment.improvement_potential <= IP_THRESHOLD) return false; // truly frozen

  const revision = await llm(
    PROMPT_STROKE_S,  // §6.6 template
    JSON.stringify(assessment)
  );
  mkdirSync(join(vault, 'shapes'), { recursive: true });
  writeFileSync(join(vault, `shapes/rev_${ts()}.md`), revision);
  return true; // vault unfrozen, restart DIAD
}

// ── Main loop ──────────────────────────────────────────────────────────────
for (let pass = 0; pass < PASS_LIMIT; pass++) {
  igParse();
  const violations = igValidate();

  if (violations.length > 0) {
    await runDIAD(violations);
  } else {
    const unfrozen = await runS();
    if (!unfrozen) {
      console.log(`Vault frozen after ${pass + 1} passes.`);
      break;
    }
  }
}
```

`executeToolCalls` reads `p:toolCall` literals from the stub MDLD, dispatches the declared tool (web fetch, SPARQL, API call), and returns the result as MDLD annotations. The loop never touches Turtle directly — all writes go through MDLD.

---

## 8. Scale Examples

### 8.1 Scale 1 — Shell: Spanish Countries

```md
# Spanish Countries Goal {=vx:goal .prov:Entity label}
[Build verifiable list of Spanish-speaking countries] {p:desiredState}
[All 21 countries grounded with REST Countries API] {p:frozenState}
{=}
# Research Plan v1 {=vx:plan_v1 .prov:Plan label}
[Goal] {=vx:goal ?prov:wasDerivedFrom}
Steps: {?p:step}
- [Fetch restcountries.com/v3.1/lang/es] {=vx:step:fetch label}
- [Extract name, capital, population per country] {=vx:step:extract label}
- [Ground each as rdf:Statement with hadPrimarySource] {=vx:step:ground label}
```

```bash
ig-cli parse vault/ -o graph.ttl
ig-cli validate --graph graph.ttl --shapes shapes/ > violations.json
# Human: read violations.json → write MDLD annotation → repeat
# S stroke: human edits shapes/ after each frozen state
```

### 8.2 Scale 2 — Document Vortex: Scientific Paper Index

Showing a second domain proves DIADS generalises. The patterns are identical — only prefix IRIs and domain vocabulary change.

**Intake (D):**
```md
[prov]  <http://www.w3.org/ns/prov#>
[vx]    <tag:papers@lab.example.com,2026:>
[p]     <tag:papers@lab.example.com,2026:prop:>
[dct]   <http://purl.org/dc/terms/>

# Paper: Attention Is All You Need {=vx:paper:vaswani2017 .prov:Entity label}
[2026-02-27T09:00:00Z] {p:retrievedAt ^^xsd:dateTime}
<https://arxiv.org/abs/1706.03762> {?prov:hadPrimarySource}
```

**Grounding (D2) — one fact per rdf:Statement:**
```md
# Fact: Vaswani 2017 → title → Attention Is All You Need {=vx:stmt:vaswani_title .rdf:Statement .prov:Entity label}
[Paper entity] {=vx:paper:vaswani2017 ?rdf:subject}
[dct:title predicate] {=dct:title ?rdf:predicate}
[Attention Is All You Need] {rdf:object}
[Fetch Activity] {=vx:activity:fetch_001 ?prov:wasGeneratedBy}
<https://arxiv.org/abs/1706.03762> {?prov:hadPrimarySource}

# Fact: Vaswani 2017 → year → 2017 {=vx:stmt:vaswani_year .rdf:Statement .prov:Entity label}
[Paper entity] {=vx:paper:vaswani2017 ?rdf:subject}
[dct:date predicate] {=dct:date ?rdf:predicate}
[2017] {rdf:object ^^xsd:gYear}
[Fetch Activity] {=vx:activity:fetch_001 ?prov:wasGeneratedBy}
<https://arxiv.org/abs/1706.03762> {?prov:hadPrimarySource}
```

**S stroke — pivot to citation graph:**
```md
# Shape Revision Activity {=vx:activity:shape_rev_001 .prov:Activity label}
[SHAPE-REFINEMENT] {p:strokeType}
[2026-02-27T10:00:00Z] {prov:startedAtTime ^^xsd:dateTime}
[2026-02-27T10:01:00Z] {prov:endedAtTime ^^xsd:dateTime}
[PIVOT — 45 papers frozen with metadata only; steering toward citation network] {p:rationale}
[PIVOT] {p:operation}
Authorized by: {?prov:hadPlan}
- [Papers Plan v1] {=vx:plan_v1 label}
{=}
# Paper Citation Shape v1 {=vx:shape:citation_v1 .sh:NodeShape .prov:Entity label}
[Shape Revision Activity] {=vx:activity:shape_rev_001 !prov:generated}
[2026-02-27T10:01:00Z] {prov:generatedAtTime ^^xsd:dateTime}
Target: {?sh:targetClass}
- [Paper Entity class] {=vx:class:Paper label}
Citations required: {?sh:property}
- [dct:references — minCount 1 — Violation — Paper has no citation links — fetch from Semantic Scholar API] {=vx:prop:cites label}
```

45 papers × 1 new violation each = 45 new violations → vault unfreezes → next DIAD pass fetches citation data.

### 8.3 Scale 3 — Vault Federation

When two vaults accumulate overlapping entities, merge them with a federation activity:

```md
[prov]  <http://www.w3.org/ns/prov#>
[owl]   <http://www.w3.org/2002/07/owl#>
[vx]    <tag:federated@example.com,2026:>
[vxA]   <tag:vault-a@example.com,2026:>
[vxB]   <tag:vault-b@example.com,2026:>

# Federation Activity {=vx:activity:federate_001 .prov:Activity label}
[2026-02-27T15:00:00Z] {prov:startedAtTime ^^xsd:dateTime}
[2026-02-27T15:05:00Z] {prov:endedAtTime ^^xsd:dateTime}
Authorized by: {?prov:hadPlan}
- [Federation Plan] {=vx:plan:federate label}
{=}
# Spain — Canonical Entity {=vx:country:spain .prov:Entity label}
[Federation Activity] {=vx:activity:federate_001 ?prov:wasGeneratedBy}
Derived from: {?prov:wasDerivedFrom}
- [Vault A Spain] {=vxA:country:spain label}
- [Vault B Spain] {=vxB:country:spain label}
[Vault A Spain] {=vxA:country:spain ?owl:sameAs}
[Vault B Spain] {=vxB:country:spain ?owl:sameAs}
```

`owl:sameAs` preserves query-time equivalence; `prov:wasDerivedFrom` preserves the audit trail. SHACL validation on the merged graph surfaces inconsistencies between the two vaults as violations the next DIAD pass must resolve.

---

## 9. Error Recovery

**Failed tool calls** must not leave PENDING activities dangling (`Temporal` shape fires on missing `prov:endedAtTime` indefinitely). Recovery pattern:

```md
# Failed Activity {=vx:activity:fetch_FAILED .prov:Activity label}
[FAILED] {p:status}
[2026-02-27T11:00:00Z] {prov:startedAtTime ^^xsd:dateTime}
[2026-02-27T11:00:03Z] {prov:endedAtTime ^^xsd:dateTime}
[HTTP 429 rate limit — retry after 60s] {p:errorMessage}
Retry queued: {?prov:wasRevisionOf}
- [Retry Activity stub] {=vx:activity:fetch_RETRY label}
```

Failed activities are never deleted — they are provenance and may explain later anomalies. The `prov:wasRevisionOf` link points to the retry stub the agent immediately creates as a new PENDING activity, restarting the pressure for that violation.

**Large vault context management** — when the graph exceeds LLM context limits, the runner compresses the graph summary to the minimum needed for the current stroke. For DIAD strokes, only the focus node and its immediate neighbours are needed. For the S stroke, only the aggregate metrics matter, not individual triples. The SPARQL summary query caps output at 3000 characters; the assessment prompt (§6.7) produces the structured JSON that replaces raw graph content for the S-stroke prompt.

---

## 10. Multi-Agent Shape Authority

In multi-agent vaults, shape refinement is a **privileged operation**. A meta-shape restricts it:

```md
# Shape Authority Meta-Shape {=vx:shape:meta_authority .sh:NodeShape .prov:Entity label}
[Orchestrator activity] {=vx:activity:bootstrap !prov:generated}
[Only orchestrator agent may generate shapes] {p:description}
Target: {?sh:targetClass}
- [NodeShape class] {=sh:NodeShape label}
Generator constraint: {?sh:property}
- [wasGeneratedBy — sh:hasValue vx:agent:orchestrator — Violation — Shape requires orchestrator authority] {=vx:prop:shape_auth label}
```

Workers run DIAD strokes. The orchestrator runs the S stroke. Propulsion is separated from steering using the same constraint mechanism that governs everything else.

---

## 11. Vault Health Dashboard

```sparql
SELECT
  (COUNT(DISTINCT ?e)   AS ?entities)
  (COUNT(DISTINCT ?a)   AS ?activities)
  (COUNT(DISTINCT ?s)   AS ?grounded_stmts)
  (COUNT(DISTINCT ?sh)  AS ?active_shapes)
  (COUNT(DISTINCT ?o)   AS ?orphans)
  (xsd:float(?s) / IF(?e=0,1,xsd:float(?e)) AS ?compression_R)
WHERE {
  OPTIONAL { ?e a prov:Entity }
  OPTIONAL { ?a a prov:Activity }
  OPTIONAL { ?s a rdf:Statement ; prov:hadPrimarySource ?src
             FILTER(STRSTARTS(STR(?src),"https://")) }
  OPTIONAL { ?sh a sh:NodeShape ; prov:wasGeneratedBy ?ga }
  OPTIONAL { ?o a prov:Entity
             FILTER NOT EXISTS { ?o prov:hadPrimarySource ?x }
             FILTER NOT EXISTS { ?o prov:wasGeneratedBy ?y } }
}
```

**Improvement potential** (multi-factor, 0.0–1.0):

```sparql
SELECT (AVG(?score) AS ?improvement_potential) WHERE {
  ?entity a prov:Entity ; prov:hadPrimarySource ?src .
  # F1: sparse statements (weight 0.4)
  { SELECT ?entity (IF(COUNT(?s)<3, 0.4, 0.0) AS ?f1)
    WHERE { OPTIONAL { ?s rdf:subject ?entity } } GROUP BY ?entity }
  # F2: no cross-links to other vault entities (weight 0.3)
  { SELECT ?entity (IF(COUNT(?link)=0, 0.3, 0.0) AS ?f2)
    WHERE { OPTIONAL { ?entity ?p ?o . ?o a prov:Entity . FILTER(?o != ?entity) }
    } GROUP BY ?entity }
  # F3: no revision in >90 days (weight 0.3)
  { SELECT ?entity (IF(?age > 7776000 && !BOUND(?rev), 0.3, 0.0) AS ?f3)
    WHERE { ?entity prov:generatedAtTime ?t .
            BIND(NOW() - ?t AS ?age)
            OPTIONAL { ?entity prov:wasRevisionOf ?rev } } }
  BIND(?f1 + ?f2 + ?f3 AS ?score)
}
```

---

## 12. Physical Model — W3C Mapping

| Physical Concept | Realisation |
|-----------------|-------------|
| Toroidal vortex ring | Entity → Activity → Entity cycle across MDLD files |
| Vortex core | `prov:Plan` / Goal entity |
| Surface tension | Active SHACL shape set |
| Throttle | Shape `sh:minCount` values |
| Steering | Shape `sh:targetClass` and `sh:property` path |
| Engine management | S stroke — shape revision activity |
| Frozen state | `violations = 0 AND IP ≤ threshold` |
| Stagnant state | `violations = 0 AND IP > threshold` → S fires |
| Hallucination | Ungrounded entity — caught by Grounding shape |
| Partial failure | PENDING activity without `endedAtTime` — caught by Temporal shape |

**Helmholtz theorem**: Vorticity cannot be created from nothing. Every entity needs provenance (`wasGeneratedBy` or `hadPrimarySource`). Every shape needs provenance (`wasGeneratedBy`). The law applies equally to data and to the rules that govern data.

**Reynolds number** governs S-stroke response:

```
Re = (ρ_entities × v_activities × L_plan) / μ_viscosity
```

| Vault state | S response | Re effect |
|-------------|-----------|-----------|
| High violations, slow resolution | Loosen shapes | ↓μ → ↑Re → faster throughput |
| Zero violations, IP > threshold | Tighten or Pivot | ↑μ → ↓Re → deeper quality |
| Zero violations, IP ≤ threshold | EXIT | Re → 0; truly frozen |

---

## 13. W3C Standards Alignment

| Standard | Role |
|----------|------|
| **PROV-O** (W3C Rec) | Causal backbone for knowledge entities, activities, agents, plans, and shapes |
| **SHACL** (W3C Rec) | Constraint-as-propulsion; constraint-as-steering; meta-constraint on shapes |
| **MDLD / MD-LD** | Unified write surface for knowledge, shapes, and agent instructions |
| **RDF 1.1** | Graph substrate; `rdf:Statement` for reified grounded facts |
| **SPARQL 1.1** | Health metrics, improvement potential, provenance chain queries |
| **XSD** | Typed literals for temporal and numeric data |
| **OWL** | `owl:sameAs` for vault federation identity |

---

## 14. Shape Library Conventions

```
vault/shapes/
  core.ttl          ← §4 universal starter (boot every vault with this)
  domain/
    geographic.ttl  ← country, capital, population, coordinates
    scientific.ttl  ← paper, doi, citation, author, year
    legal.ttl       ← statute, jurisdiction, effective date, amendment
    temporal.ttl    ← event, duration, recurrence patterns
```

All domain shapes are generated by S-stroke activities and committed as MDLD (`.md`) or Turtle (`.ttl`) with `prov:wasGeneratedBy` provenance. The shape file is always the minimum viable shape for that domain — further tightening happens in subsequent S strokes as the vault accumulates evidence about what is actually achievable.

---

*The vortex achieves its deepest coherence when shapes are treated as first-class knowledge: authored, versioned, and provenanced in the same MDLD substrate as the facts they govern. A frozen vault without the S stroke has merely run out of violations. A vault with the S stroke has either genuinely completed its work — or consciously chosen to sleep, knowing it can be woken by a single shape revision that makes the familiar strange again.*
